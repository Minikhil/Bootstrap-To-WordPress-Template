class ArrayIterator
	private a_
	private i_
	private l_
	
	public sub init (a, l)
		a_ = a
		l_ = l
		i_ = 0
	end sub
	
	public function has_current
		has_current = (i_ < l_)
	end function
	
	public function move_next
		i_ = i_ + 1
	end function
	
	public function value
		assign value, a_(i_)
	end function
	
	public function pop
		assign pop, a_(i_)
		i_ = i_ + 1
	end function
end class

class RecordSetIterator
	private rs_
	
	public sub init (rs)
		set rs_ = rs
	end sub
	
	public function has_current
		has_current = not rs_.eof
	end function
	
	public function move_next
		rs_.moveNext
	end function
	
	public function move_first
		rs_.moveFirst
	end function
	
	public default property get value(field)
		value = rs_(field)
	end property
end class

class RecordSetKVIterator
	private rs_
	private key_
	private value_
	
	public sub init (rs, key, value)
		set rs_ = rs
		key_ = key
		value_ = value
	end sub
	
	public function has_current
		has_current = not rs_.eof
	end function
	
	public function move_next
		rs_.moveNext
	end function
	
	public function move_first
		rs_.moveFirst
	end function
	
	public function key
		key = rs_(key_)
	end function
	
	public function value
		value = rs_(value_)
	end function
	
	public function pop
		pop = rs_(value_)
		rs_.move_next
	end function
end class

class RecordIterator
	private rs_
	private fields_itr_
	private i_
	private l_
	
	public sub init (rs)
		set rs_ = rs
		i_ = 0
		l_ = rs.fields.count
	end sub
	
	public function has_current
		has_current = (i_ < l_)
	end function
	
	public function move_next
		i_ = i_ + 1
	end function
	
	public function key
		key = rs_.fields(i_).name
	end function
	
	public function value
		value = rs_(i_)
	end function
	
	public function pop
		pop = rs_(i_)
		i_ = i_ + 1
	end function
end class

class DateTimeIterator
	private current_
	private finish_
	private increment_
	
	public sub init (start, finish, increment)
		set current_ = start
		set finish_ = finish
		set increment_ = increment
	end sub
	
	public function has_current
		has_current = (current_.cmp(finish_) <= 0)
	end function
	
	public function move_next
		set current_ = current_.plus(increment_)
	end function
	
	public function value
		set value = current_
	end function
	
	public function pop
		set pop = current_
		set current_ = current_.plus(increment_)
	end function
end class

class DictionaryIterator
	private dictionary_
	private array_iterator_
	
	public sub init (dictionary)
		set dictionary_ = dictionary
		set array_iterator_ = Iterator.from_array(dictionary.keys)
	end sub
	
	public function has_current
		has_current = array_iterator_.has_current
	end function
	
	public function move_next
		array_iterator_.move_next
	end function
	
	public function key
		assign key, array_iterator_.value
	end function
	
	public function value
		assign value, dictionary_(array_iterator_.value)
	end function
end class

class StringIterator
	private str_
	private i_
	
	public sub init (str)
		str_ = str
		i_ = 1
	end sub
	
	public function has_current
		has_current = (i_ <= len(str_))
	end function
	
	public function value
		value = mid(str_, i_, 1)
	end function
	
	public function move_next
		i_ = i_ + 1
	end function
	
	public function pop
		pop = mid(str_, i_, 1)
		i_ = i_ + 1
	end function
	
	public function move (distance)
		move = mid(str_, i_, distance)
		i_ = i_ + distance
	end function
	
	public function seek (char)
		dim loc: loc = inStr(i_, str_, char, 0)
		if loc = 0 then
			seek = right(str_, len(str_) - i_ + 1)
			i_ = len(str_) + 1
		else
			seek = mid(str_, i_, loc - i_)
			i_ = loc
		end if
	end function
end class

class IteratorModule
	public default property get construct (iterable)
		if isArray(iterable) then
			set construct = from_array(iterable)
		elseif isObject(iterable) then
			select case typeName(iterable)
				case "Recordset": set construct = from_record_set(iterable)
				case else: set construct = iterable.iterator
			end select
		end if
	end property
	
	public function from_array (a)
		set from_array = new ArrayIterator
		from_array.init a, uBound(a) + 1
	end function
	
	public function from_array_length (a, l)
		set from_array_length = new ArrayIterator
		from_array_length.init a, l
	end function
	
	public function from_record_set (rs)
		set from_record_set = new RecordSetIterator
		from_record_set.init(rs)
	end function
	
	public function from_record_set_map (rs, key, val)
		set from_record_set_map = new RecordSetKVIterator
		from_record_set_map.init rs, key, val
	end function
	
	public function from_record (rs)
		set from_record = new RecordIterator
		from_record.init(rs)
	end function
	
	public function from_datetime (start, finish, increment)
		set from_datetime = new DateTimeIterator
		from_datetime.init start, finish, increment
	end function
	
	public function from_dictionary (dictionary)
		set from_dictionary = new DictionaryIterator
		from_dictionary.init dictionary
	end function
	
	public function from_string (str)
		set from_string = new StringIterator
		from_string.init str
	end function
	
	public function html_dump (iterable)
		with construct(iterable)
			do while .has_current
				prints "\$<br>\n", Array(.value)
				.move_next
			loop
		end with
	end function
end class
dim Iterator: set Iterator = new IteratorModule